var documenterSearchIndex = {"docs":
[{"location":"priors/#Priors-1","page":"Priors","title":"Priors","text":"","category":"section"},{"location":"priors/#","page":"Priors","title":"Priors","text":"The package currently support two priors, NIW for observations generated from gaussians, and Dirichlet Distribution for multinomial data.","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"Each prior is defined by the prior itself, and the distribution which is sampled from it.","category":"page"},{"location":"priors/#Existing-Priors-1","page":"Priors","title":"Existing Priors","text":"","category":"section"},{"location":"priors/#NIW-(Gaussian)-1","page":"Priors","title":"NIW (Gaussian)","text":"","category":"section"},{"location":"priors/#","page":"Priors","title":"Priors","text":"For data generated from Gaussians we use a NIW prior, which a Multivariate Normal distribution is sampled from:","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"DPMMSubClusters.niw_hyperparams\nDPMMSubClusters.mv_gaussian","category":"page"},{"location":"priors/#DPMMSubClusters.niw_hyperparams","page":"Priors","title":"DPMMSubClusters.niw_hyperparams","text":"niw_hyperparams(κ::Float32, m::AbstractArray{Float32}, ν::Float32, ψ::AbstractArray{Float32})\n\nNormal Inverse Wishart\n\n\n\n\n\n","category":"type"},{"location":"priors/#DPMMSubClusters.mv_gaussian","page":"Priors","title":"DPMMSubClusters.mv_gaussian","text":"mv_gaussian(μ::AbstractArray{Float32,1}\n    Σ::AbstractArray{Float32,2}\n    invΣ::AbstractArray{Float32,2}\n    logdetΣ::Float32\n    invChol::UpperTriangular)\n\nMultivariate Normal Distribution\n\n\n\n\n\n","category":"type"},{"location":"priors/#Multinomial-1","page":"Priors","title":"Multinomial","text":"","category":"section"},{"location":"priors/#","page":"Priors","title":"Priors","text":"For multinomial distribution we will a Dirichlet Distribution prior, and a Categorial Distribution is sampled from it.","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"DPMMSubClusters.multinomial_hyper\nDPMMSubClusters.multinomial_dist","category":"page"},{"location":"priors/#DPMMSubClusters.multinomial_hyper","page":"Priors","title":"DPMMSubClusters.multinomial_hyper","text":"multinomial_hyper(α::AbstractArray{Float32,1})\n\nDirichlet Distribution\n\n\n\n\n\n","category":"type"},{"location":"priors/#DPMMSubClusters.multinomial_dist","page":"Priors","title":"DPMMSubClusters.multinomial_dist","text":"multinomial_hyper(α::AbstractArray{Float32,1})\n\nDirichlet Distribution\n\n\n\n\n\n","category":"type"},{"location":"priors/#Creating-new-Priors-1","page":"Priors","title":"Creating new Priors","text":"","category":"section"},{"location":"priors/#","page":"Priors","title":"Priors","text":"If you require to create a new prior, you need to create both a distribution file, and a prior file (each in its designated folder). Note that the package only support conjugate priors.","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"The prior file must implement the following:","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"struct prior_hyper_params <: distribution_hyper_params\n    ...\nend\n\nmutable struct prior_sufficient_statistics <: sufficient_statistics\n    N::Float32 #Must have this, even if not needed!\n    ...\nend\n\n\nfunction calc_posterior(prior:: prior_hyper_params, suff_statistics::prior_sufficient_statistics)\n    if suff_statistics.N == 0\n        return prior\n    end\n    return prior_hyper_params(...)\nend\n\nfunction sample_distribution(hyperparams::prior_hyper_params)\n    return new_dist(...)\nend\n\nfunction create_sufficient_statistics(hyper::prior_hyper_params,posterior::prior_hyper_params,points::AbstractArray{Float32,2}, pts_to_group = 0)\n    pts = copy(points)\n    ...\n    return prior_sufficient_statistics(size(points,2),...)\nend\n\nfunction log_marginal_likelihood(hyper::prior_hyper_params, posterior_hyper::prior_hyper_params, suff_stats::prior_sufficient_statistics)\n    ...\n    return value\nend\n\nfunction aggregate_suff_stats(suff_l::prior_sufficient_statistics, suff_r::prior_sufficient_statistics)\n    return prior_sufficient_statistics(...)\nend","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"For the distribution file you must implement the following:","category":"page"},{"location":"priors/#","page":"Priors","title":"Priors","text":"struct new_dist <: distibution_sample\n    ...\nend\n\n\nfunction log_likelihood!(r::AbstractArray,x::AbstractMatrix, distibution_sample::mv_gaussian , group::Int64 = -1)\n     ...\n    r .= (each sample log likelihood)\nend","category":"page"},{"location":"usage/#Usage-1","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package offer two type of modes for running it, Basic and Advanced.","category":"page"},{"location":"usage/#Basic-1","page":"Usage","title":"Basic","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"This mode will run with mostly predefined settings, saving checkpoints is not recommended in this mode. The model is run by using the fit method, with a minimal requirements of the Data and α concentration parameter. when prior is not supplied, it will automatically use a weak NIW prior.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = DPMMSubClusters","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"fit(all_data::AbstractArray{Float32,2},local_hyper_params::distribution_hyper_params,α_param::Float32;\n        iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false, burnout = 20, gt = nothing)\nfit(all_data::AbstractArray{Float32,2},α_param::Float32;\n        iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false,burnout = 20, gt = nothing)","category":"page"},{"location":"usage/#DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},DPMMSubClusters.distribution_hyper_params,Float32}","page":"Usage","title":"DPMMSubClusters.fit","text":"fit(all_data::AbstractArray{Float32,2},local_hyper_params::distribution_hyper_params,α_param::Float32;\n        iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false, burnout = 20, gt = nothing)\n\nRun the model (basic mode).\n\nArgs and Kwargs\n\nall_data::AbstractArray{Float32,2} a DxN array containing the data\nlocal_hyper_params::distribution_hyper_params the prior hyperparams\nα_param::Float32 the concetration parameter\niters::Int64 number of iterations to run the model\ninit_clusters::Int64 number of initial clusters\nseed define a random seed to be used in all workers, if used must be preceeded with @everywhere using random.\nverbose will perform prints on every iteration.\nsave_model will save a checkpoint every 25 iterations.\nburnout how long to wait after creating a cluster, and allowing it to split/merge\ngt Ground truth, when supplied, will perform NMI and VI analysis on every iteration.\n\nReturn Values\n\nlabels Labels assignments\nclusters Cluster parameters\nweights The cluster weights, does not sum to 1, but to 1 minus the weight of all uninstanistaed clusters.\niter_count Timing for each iteration\nnmi_score_history NMI score per iteration (if gt suppled)\nlikelihood_history Log likelihood per iteration.\ncluster_count_history Cluster counts per iteration.\n\nExample:\n\njulia> x,y,clusters = generate_gaussian_data(10000,2,6,100.0)\n...\n\njulia> hyper_params = DPMMSubClusters.niw_hyperparams(1.0,\n                  zeros(2),\n                  5,\n                  [1 0;0 1])\nDPMMSubClusters.niw_hyperparams(1.0f0, Float32[0.0, 0.0], 5.0f0, Float32[1.0 0.0; 0.0 1.0])\n\njulia> ret_values= fit(x,hyper_params,10.0, iters = 100, verbose=false)\n\n...\n\njulia> unique(ret_values[1])\n6-element Array{Int64,1}:\n 3\n 6\n 1\n 2\n 5\n 4\n\n\n\n\n\n","category":"method"},{"location":"usage/#DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},Float32}","page":"Usage","title":"DPMMSubClusters.fit","text":"fit(all_data::AbstractArray{Float32,2},α_param::Float32;\n        iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false, burnout = 20, gt = nothing)\n\nRun the model (basic mode) with default NIW prior.\n\nArgs and Kwargs\n\nall_data::AbstractArray{Float32,2} a DxN array containing the data\nα_param::Float32 the concetration parameter\niters::Int64 number of iterations to run the model\ninit_clusters::Int64 number of initial clusters\nseed define a random seed to be used in all workers, if used must be preceeded with @everywhere using random.\nverbose will perform prints on every iteration.\nsave_model will save a checkpoint every 25 iterations.\nburnout how long to wait after creating a cluster, and allowing it to split/merge\ngt Ground truth, when supplied, will perform NMI and VI analysis on every iteration.\n\nReturn Values\n\nlabels Labels assignments\nclusters Cluster parameters\nweights The cluster weights, does not sum to 1, but to 1 minus the weight of all uninstanistaed clusters.\niter_count Timing for each iteration\nnmi_score_history NMI score per iteration (if gt suppled)\nlikelihood_history Log likelihood per iteration.\ncluster_count_history Cluster counts per iteration.\n\nExample:\n\njulia> x,y,clusters = generate_gaussian_data(10000,2,6,100.0)\n...\n\njulia> ret_values= fit(x,10.0, iters = 100, verbose=false)\n\n...\n\njulia> unique(ret_values[1])\n6-element Array{Int64,1}:\n 3\n 6\n 1\n 2\n 5\n 4\n\n\n\n\n\n","category":"method"},{"location":"usage/#Advanced-1","page":"Usage","title":"Advanced","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"This mode allows greater flexibility, and required a Parameters file (see below). It is run by the function dp_parallel.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"dp_parallel(model_params::String; verbose = true, save_model = true,burnout = 5, gt = nothing)","category":"page"},{"location":"usage/#DPMMSubClusters.dp_parallel-Tuple{String}","page":"Usage","title":"DPMMSubClusters.dp_parallel","text":"dp_parallel(model_params::String; verbose = true, save_model = true,burnout = 5, gt = nothing)\n\nRun the model in advanced mode.\n\nArgs and Kwargs\n\nmodel_params::String A path to a parameters file (see below)\nverbose will perform prints on every iteration.\nsave_model will save a checkpoint every X iterations, where X is specified in the parameter file.\nburnout how long to wait after creating a cluster, and allowing it to split/merge\ngt Ground truth, when supplied, will perform NMI and VI analysis on every iteration.\n\nReturn values\n\ndpmodel, itercount , nmiscorehistory, liklihoodhistory, clustercount_history\n\ndp_model The DPMM model inferred\niter_count Timing for each iteration\nnmi_score_history NMI score per iteration (if gt suppled)\nlikelihood_history Log likelihood per iteration.\ncluster_count_history Cluster counts per iteration.\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"In addition, you may restart a previously saved checkpoint:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"run_model_from_checkpoint(filename)","category":"page"},{"location":"usage/#DPMMSubClusters.run_model_from_checkpoint-Tuple{Any}","page":"Usage","title":"DPMMSubClusters.run_model_from_checkpoint","text":"run_model_from_checkpoint(filename)\n\nRun the model from a checkpoint created by it, filename is the path to the checkpoint. Only to be run when using the advanced mode, note that the data must be in the same path as previously.\n\nExample:\n\njulia> dp = run_model_from_checkpoint(\"checkpoint__50.jld2\")\nLoading Model:\n  1.073261 seconds (2.27 M allocations: 113.221 MiB, 2.60% gc time)\nIncluding params\nLoading data:\n  0.000881 seconds (10.02 k allocations: 378.313 KiB)\nCreating model:\nNode Leaders:\nDict{Any,Any}(2=>Any[2, 3])\nRunning model:\n...\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Note that that data is read from a npy file, and unlike the previous fit function, should be of Samples X Dimensions.","category":"page"},{"location":"usage/#Parameter-File-1","page":"Usage","title":"Parameter File","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"For running the advanced mode you need to specify a parameters file, it is a Julia file, of the following struct:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"#Data Loading specifics\ndata_path = \"/path/to/data/\"\ndata_prefix = \"data_prefix\"  #If the data file name is bob.npy, this should be 'bob'\n\n\n#Model Parameters\niterations = 100\nhard_clustering = false  #Soft or hard assignments\ninitial_clusters = 1\nargmax_sample_stop = 0 #Change to hard assignment from soft at iterations - argmax_sample_stop\nsplit_stop  = 0 #Stop split/merge moves at  iterations - split_stop\n\nrandom_seed = nothing #When nothing, a random seed will be used.\n\nmax_split_iter = 20\nburnout_period = 20\n\n#Model hyperparams\nα = 10.0 #Concetration Parameter\nhyper_params = DPMMSubClusters.niw_hyperparams(1.0,\n    zeros(Float32,2),\n    5,\n    Matrix{Float32}(I, 2, 2)*1.0)\n\n\n\n#Saving specifics:\nenable_saving = true\nmodel_save_interval = 1000\nsave_path = \"/path/to/save/dir/\"\noverwrite_prec = false\nsave_file_prefix = \"checkpoint_\"","category":"page"},{"location":"getting_started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"The package is available through Julia package repository. Install by either:","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"] add DPMMSubClusters","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"Or","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> Pkg.add(\"DPMMSubClusters\")","category":"page"},{"location":"getting_started/#Simple-example-to-get-you-started-1","page":"Getting Started","title":"Simple example to get you started","text":"","category":"section"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"Start by setting the environment:","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using DPMMSubClusters","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"Continue by generating some random data, we will generate 10000 samples, taken from a mixture of 6 2D Gaussians, their mean sampled from a normal distribution with variance of 100:","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> x,y,clusters = generate_gaussian_data(10000,2,6,100.0)\n...","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"We will now run the model with a default NIW prior, burnout period of 10, and with the GT we have generated:","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> ret_values= fit(x,10.0, iters = 100,burnout = 10, gt = y)\nIteration: 1 || Clusters count: 1 || Log posterior: -70361.61688103084 || Vi score: 1.2054788914293095 || NMI score: 1.8419617838497155e-15 || Iter Time:0.005878925323486328 || Total time:0.005878925323486328\n...\nIteration: 100 || Clusters count: 6 || Log posterior: -33552.84821500185 || Vi score: -0.0 || NMI score: 1.0 || Iter Time:0.013663053512573242 || Total time:1.0682177543640137\n...","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"Now we can examine the labels by accessing the returned values:","category":"page"},{"location":"getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> labels = ret_values[1]\n4\n4\n4\n4\n4\n4\n4\n⋮\n2\n2\n2\n2\n2\n2","category":"page"},{"location":"#DPMMSubClusters.jl-1","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"","category":"section"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Package provides an easy, fast and scalable way to perform inference in Dirichlet Process Mixture Models.","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"https://github.com/dinarior/DPMMSubClusters.jl","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Developed from the code of:","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":" Distributed MCMC Inference in Dirichlet Process Mixture Models Using Julia by Dinari et al.","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Which is based on the algorithm from:","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Parallel Sampling of DP Mixture Models using Sub-Clusters Splits by Chang and Fisher.","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"The package currently supports Gaussian and Multinomial priors, however adding your own is very easy, and more will come in future releases.","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Examples:","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"2d Gaussian with plotting","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Image Segmentation","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Example of running from a params file, including saving and loading","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"If you use this package in your research, please cite the following:","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"@inproceedings{Dinari:CCGrid:2019,\n  title={Distributed {MCMC} Inference in {Dirichlet} Process Mixture Models Using {Julia}},\n  author={Dinari, Or and Angel, Yu and Freifeld, Oren and Fisher III, John W},\n  booktitle={International Symposium on Cluster, Cloud and Grid Computing (CCGRID) Workshop on High Performance Machine Learning Workshop},\n  year={2019}\n}","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"For any questions: dinari@post.bgu.ac.il Also available on Julia's Slack.","category":"page"},{"location":"#","page":"DPMMSubClusters.jl","title":"DPMMSubClusters.jl","text":"Contributions, feature requests, suggestion etc.. are welcomed.","category":"page"},{"location":"data_generation/#Data-Generators-1","page":"Data Generators","title":"Data Generators","text":"","category":"section"},{"location":"data_generation/#","page":"Data Generators","title":"Data Generators","text":"The package offers (currently) two data generators, one for Multinomial priors, and the other for Gaussians.","category":"page"},{"location":"data_generation/#","page":"Data Generators","title":"Data Generators","text":"CurrentModule = DPMMSubClusters","category":"page"},{"location":"data_generation/#","page":"Data Generators","title":"Data Generators","text":"generate_gaussian_data\ngenerate_mnmm_data","category":"page"},{"location":"data_generation/#DPMMSubClusters.generate_gaussian_data","page":"Data Generators","title":"DPMMSubClusters.generate_gaussian_data","text":"generate_gaussian_data(N::Int64, D::Int64, K::Int64,MixtureVar::Number)\n\nGenerate N observations, generated from K D dimensions Gaussians, with the Gaussian means sampled from a Normal distribution with mean 0 and MixtureVar variance.\n\nReturns (Samples, Labels, Clusters_means, Clusters_cov)\n\nExample\n\njulia> x,y,clusters = generate_gaussian_data(10000,2,6,100.0)\n[3644, 2880, 119, 154, 33, 3170]\n...\n\n\n\n\n\n","category":"function"},{"location":"data_generation/#DPMMSubClusters.generate_mnmm_data","page":"Data Generators","title":"DPMMSubClusters.generate_mnmm_data","text":" generate_mnmm_data(N::Int64, D::Int64, K::Int64, trials::Int64)\n\nGenerate N observations, generated from K D features Multinomial vectors, with trials draws from each vector.\n\nReturns (Samples, Labels, Vectors)\n\nExample\n\njulia> generate_mnmm_data(10000, 10, 5, 100)\n...\n\n\n\n\n\n","category":"function"},{"location":"perf/#Performance-Tips-1","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"perf/#","page":"Performance Tips","title":"Performance Tips","text":"This package support multiple processes, over multiple machines, and will use all the available worker processes. Note that when running without any worker processes it will use the master process.","category":"page"},{"location":"perf/#","page":"Performance Tips","title":"Performance Tips","text":"For optimal performance, run with BLAS.set_num_threads(1).","category":"page"},{"location":"perf/#","page":"Performance Tips","title":"Performance Tips","text":"The performance increase is not linear with the processes, and on small data sets of lower dimensions adding more processes might even reduce performance.","category":"page"},{"location":"perf/#","page":"Performance Tips","title":"Performance Tips","text":"Optimization contributions are very welcomed!.","category":"page"}]
}
