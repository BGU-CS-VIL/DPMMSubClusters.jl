<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · DPMMSubClusters.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DPMMSubClusters.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">DPMMSubClusters.jl</a></li><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li class="current"><a class="toctext" href>Usage</a><ul class="internal"><li><a class="toctext" href="#Basic-1">Basic</a></li><li><a class="toctext" href="#Advanced-1">Advanced</a></li></ul></li><li><a class="toctext" href="../priors/">Priors</a></li><li><a class="toctext" href="../data_generation/">Data Generators</a></li><li><a class="toctext" href="../perf/">Performance Tips</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage</a></li></ul><a class="edit-page" href="https://github.com/BGU-CS-VIL/DPMMSubClusters.jl/blob/master/docs/src/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h1><p>The package offer two type of modes for running it, <em>Basic</em> and <em>Advanced</em>.</p><h2><a class="nav-anchor" id="Basic-1" href="#Basic-1">Basic</a></h2><p>This mode will run with mostly predefined settings, saving checkpoints is not recommended in this mode. The model is run by using the <code>fit</code> method, with a minimal requirements of the <code>Data</code> and <code>α</code> concentration parameter. when <code>prior</code> is not supplied, it will automatically use a weak <code>NIW</code> prior.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},DPMMSubClusters.distribution_hyper_params,Float32}" href="#DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},DPMMSubClusters.distribution_hyper_params,Float32}"><code>DPMMSubClusters.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(all_data::AbstractArray{Float32,2},local_hyper_params::distribution_hyper_params,α_param::Float32;
   iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false, burnout = 20, gt = nothing, max_clusters = Inf, outlier_weight = 0, outlier_params = nothing)</code></pre><p>Run the model (basic mode).</p><p><strong>Args and Kwargs</strong></p><ul><li><code>all_data::AbstractArray{Float32,2}</code> a <code>DxN</code> array containing the data</li><li><code>local_hyper_params::distribution_hyper_params</code> the prior hyperparams</li><li><code>α_param::Float32</code> the concetration parameter</li><li><code>iters::Int64</code> number of iterations to run the model</li><li><code>init_clusters::Int64</code> number of initial clusters</li><li><code>seed</code> define a random seed to be used in all workers, if used must be preceeded with <code>@everywhere using random</code>.</li><li><code>verbose</code> will perform prints on every iteration.</li><li><code>save_model</code> will save a checkpoint every 25 iterations.</li><li><code>burnout</code> how long to wait after creating a cluster, and allowing it to split/merge</li><li><code>gt</code> Ground truth, when supplied, will perform NMI and VI analysis on every iteration.</li><li><code>max_clusters</code> limit the number of cluster</li><li><code>outlier_weight</code> constant weight of an extra non-spliting component</li><li><code>outlier_params</code> hyperparams for an extra non-spliting component</li></ul><p><strong>Return Values</strong></p><ul><li><code>labels</code> Labels assignments</li><li><code>clusters</code> Cluster parameters</li><li><code>weights</code> The cluster weights, does not sum to <code>1</code>, but to <code>1</code> minus the weight of all uninstanistaed clusters.</li><li><code>iter_count</code> Timing for each iteration</li><li><code>nmi_score_history</code> NMI score per iteration (if gt suppled)</li><li><code>likelihood_history</code> Log likelihood per iteration.</li><li><code>cluster_count_history</code> Cluster counts per iteration.</li><li><code>sub_labels</code> Sub labels assignments</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; x,y,clusters = generate_gaussian_data(10000,2,6,100.0)
...

julia&gt; hyper_params = DPMMSubClusters.niw_hyperparams(1.0,
                  zeros(2),
                  5,
                  [1 0;0 1])
DPMMSubClusters.niw_hyperparams(1.0f0, Float32[0.0, 0.0], 5.0f0, Float32[1.0 0.0; 0.0 1.0])

julia&gt; ret_values= fit(x,hyper_params,10.0, iters = 100, verbose=false)

...

julia&gt; unique(ret_values[1])
6-element Array{Int64,1}:
 3
 6
 1
 2
 5
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/BGU-CS-VIL/DPMMSubClusters.jl/blob/463133c52145f1cfb28f4d68fc739d1487239c6d/src/dp-parallel-sampling.jl#L150-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},Float32}" href="#DPMMSubClusters.fit-Tuple{AbstractArray{Float32,2},Float32}"><code>DPMMSubClusters.fit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fit(all_data::AbstractArray{Float32,2},α_param::Float32;
    iters::Int64 = 100, init_clusters::Int64 = 1,seed = nothing, verbose = true, save_model = false,burnout = 20, gt = nothing, max_clusters = Inf, outlier_weight = 0, outlier_params = nothing)</code></pre><p>Run the model (basic mode) with default <code>NIW</code> prior.</p><p><strong>Args and Kwargs</strong></p><ul><li><code>all_data::AbstractArray{Float32,2}</code> a <code>DxN</code> array containing the data</li><li><code>α_param::Float32</code> the concetration parameter</li><li><code>iters::Int64</code> number of iterations to run the model</li><li><code>init_clusters::Int64</code> number of initial clusters</li><li><code>seed</code> define a random seed to be used in all workers, if used must be preceeded with <code>@everywhere using random</code>.</li><li><code>verbose</code> will perform prints on every iteration.</li><li><code>save_model</code> will save a checkpoint every 25 iterations.</li><li><code>burnout</code> how long to wait after creating a cluster, and allowing it to split/merge</li><li><code>gt</code> Ground truth, when supplied, will perform NMI and VI analysis on every iteration.</li><li><code>outlier_weight</code> constant weight of an extra non-spliting component</li><li><code>outlier_params</code> hyperparams for an extra non-spliting component</li></ul><p><strong>Return Values</strong></p><ul><li><code>labels</code> Labels assignments</li><li><code>clusters</code> Cluster parameters</li><li><code>weights</code> The cluster weights, does not sum to <code>1</code>, but to <code>1</code> minus the weight of all uninstanistaed clusters.</li><li><code>iter_count</code> Timing for each iteration</li><li><code>nmi_score_history</code> NMI score per iteration (if gt suppled)</li><li><code>likelihood_history</code> Log likelihood per iteration.</li><li><code>cluster_count_history</code> Cluster counts per iteration.</li><li><code>sub_labels</code> Sub labels assignments</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; x,y,clusters = generate_gaussian_data(10000,2,6,100.0)
...

julia&gt; ret_values= fit(x,10.0, iters = 100, verbose=false)

...

julia&gt; unique(ret_values[1])
6-element Array{Int64,1}:
 3
 6
 1
 2
 5
 4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/BGU-CS-VIL/DPMMSubClusters.jl/blob/463133c52145f1cfb28f4d68fc739d1487239c6d/src/dp-parallel-sampling.jl#L211-L258">source</a></section><h2><a class="nav-anchor" id="Advanced-1" href="#Advanced-1">Advanced</a></h2><p>This mode allows greater flexibility, and required a <code>Parameters</code> file (see below). It is run by the function <code>dp_parallel</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DPMMSubClusters.dp_parallel-Tuple{String}" href="#DPMMSubClusters.dp_parallel-Tuple{String}"><code>DPMMSubClusters.dp_parallel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">dp_parallel(model_params::String; verbose = true, save_model = true,burnout = 5, gt = nothing)</code></pre><p>Run the model in advanced mode.</p><p><strong>Args and Kwargs</strong></p><ul><li><code>model_params::String</code> A path to a parameters file (see below)</li><li><code>verbose</code> will perform prints on every iteration.</li><li><code>save_model</code> will save a checkpoint every <code>X</code> iterations, where <code>X</code> is specified in the parameter file.</li><li><code>burnout</code> how long to wait after creating a cluster, and allowing it to split/merge</li><li><code>gt</code> Ground truth, when supplied, will perform NMI and VI analysis on every iteration.</li></ul><p><strong>Return values</strong></p><p>dp<em>model, iter</em>count , nmi<em>score</em>history, liklihood<em>history, cluster</em>count_history</p><ul><li><code>dp_model</code> The DPMM model inferred</li><li><code>iter_count</code> Timing for each iteration</li><li><code>nmi_score_history</code> NMI score per iteration (if gt suppled)</li><li><code>likelihood_history</code> Log likelihood per iteration.</li><li><code>cluster_count_history</code> Cluster counts per iteration.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/BGU-CS-VIL/DPMMSubClusters.jl/blob/463133c52145f1cfb28f4d68fc739d1487239c6d/src/dp-parallel-sampling.jl#L287-L305">source</a></section><p>In addition, you may restart a previously saved checkpoint:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DPMMSubClusters.run_model_from_checkpoint-Tuple{Any}" href="#DPMMSubClusters.run_model_from_checkpoint-Tuple{Any}"><code>DPMMSubClusters.run_model_from_checkpoint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">run_model_from_checkpoint(filename)</code></pre><p>Run the model from a checkpoint created by it, <code>filename</code> is the path to the checkpoint. Only to be run when using the advanced mode, note that the data must be in the same path as previously.</p><p><strong>Example:</strong></p><pre><code class="language-julia">julia&gt; dp = run_model_from_checkpoint(&quot;checkpoint__50.jld2&quot;)
Loading Model:
  1.073261 seconds (2.27 M allocations: 113.221 MiB, 2.60% gc time)
Including params
Loading data:
  0.000881 seconds (10.02 k allocations: 378.313 KiB)
Creating model:
Node Leaders:
Dict{Any,Any}(2=&gt;Any[2, 3])
Running model:
...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/BGU-CS-VIL/DPMMSubClusters.jl/blob/463133c52145f1cfb28f4d68fc739d1487239c6d/src/dp-parallel-sampling.jl#L395-L415">source</a></section><p>Note that that data is read from a <code>npy</code> file, and unlike the previous <code>fit</code> function, should be of <code>Samples X Dimensions</code>.</p><h3><a class="nav-anchor" id="Parameter-File-1" href="#Parameter-File-1">Parameter File</a></h3><p>For running the advanced mode you need to specify a parameters file, it is a <code>Julia</code> file, of the following struct:</p><pre><code class="language-julia">#Data Loading specifics
data_path = &quot;/path/to/data/&quot;
data_prefix = &quot;data_prefix&quot;  #If the data file name is bob.npy, this should be &#39;bob&#39;


#Model Parameters
iterations = 100
hard_clustering = false  #Soft or hard assignments
initial_clusters = 1
argmax_sample_stop = 0 #Change to hard assignment from soft at iterations - argmax_sample_stop
split_stop  = 0 #Stop split/merge moves at  iterations - split_stop

random_seed = nothing #When nothing, a random seed will be used.

max_split_iter = 20
burnout_period = 20

#Model hyperparams
α = 10.0 #Concetration Parameter
hyper_params = DPMMSubClusters.niw_hyperparams(1.0,
    zeros(Float32,2),
    5,
    Matrix{Float32}(I, 2, 2)*1.0)



#Saving specifics:
enable_saving = true
model_save_interval = 1000
save_path = &quot;/path/to/save/dir/&quot;
overwrite_prec = false
save_file_prefix = &quot;checkpoint_&quot;</code></pre><footer><hr/><a class="previous" href="../getting_started/"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="../priors/"><span class="direction">Next</span><span class="title">Priors</span></a></footer></article></body></html>
